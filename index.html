<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GodLight! - Top-Down Melee Prototype</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    /* Help button style */
    #closeHelpBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      font-size: 20px;
      background-color: #444;
      color: #fff;
      border: none;
      cursor: pointer;
      z-index: 1000;
    }
    /* HUD tooltip (stub) */
    #hudTooltip {
      position: absolute;
      padding: 5px 10px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-size: 14px;
      display: none;
      z-index: 1000;
    }
  </style>
  <!-- Load EasyStar.js (stub for A* pathfinding) -->
  <script src="https://cdn.jsdelivr.net/npm/easystarjs@0.4.4/bin/easystar-0.4.4.js"></script>
  <!-- Include Phaser.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
</head>
<body>
<div id="hudTooltip"></div>
<script>
// --- Helper functions for color adjustments ---
function lightenColor(color, percent) {
  let r = (color >> 16) & 0xFF;
  let g = (color >> 8) & 0xFF;
  let b = color & 0xFF;
  r = Math.min(255, r + Math.floor((255 - r) * percent));
  g = Math.min(255, g + Math.floor((255 - g) * percent));
  b = Math.min(255, b + Math.floor((255 - b) * percent));
  return (r << 16) + (g << 8) + b;
}
function darkenColor(color, percent) {
  let r = (color >> 16) & 0xFF;
  let g = (color >> 8) & 0xFF;
  let b = color & 0xFF;
  r = Math.max(0, r - Math.floor(r * percent));
  g = Math.max(0, g - Math.floor(g * percent));
  b = Math.max(0, b - Math.floor(b * percent));
  return (r << 16) + (g << 8) + b;
}

// --- Mapping for boon icons and texts ---
const GOD_ICONS = {
  Zeus: "⚡",
  Poseidon: "🌊",
  Athena: "🦉",
  Ares: "⚔️",
  Aphrodite: "💖",
  Apollo: "☀️",
  Artemis: "🌙",
  Hephaestus: "🔥",
  Hermes: "👟",
  Dionysus: "🍷",
  Demeter: "🌾",
  Hera: "👑",
  Hades: "💀"
};
const GOD_BOONS = {
  Zeus: "+25% DMG",
  Poseidon: "Push Allies",
  Athena: "30% Heal Chance",
  Ares: "Reflect 15%",
  Aphrodite: "Healing Mishap",
  Apollo: "-5% Accu",
  Artemis: "Random Target",
  Hephaestus: "20% Backfire",
  Hermes: "Chaotic Move",
  Dionysus: "Screen Spin",
  Demeter: "Slow Allies",
  Hera: "Tax Allies",
  Hades: "Soul Burden"
};

// --- Global Configuration ---
const GAME_WIDTH = 1536;
const GAME_HEIGHT = 1152;
const ARENA_CENTER = { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2 };
const ARENA_RADIUS = Math.min(GAME_WIDTH, GAME_HEIGHT) / 2 - 20;

const GODS = [
  { name: "Zeus",      boon: "Lightning Rod – +25% DMG" },
  { name: "Poseidon",  boon: "Unstable Tides" },
  { name: "Athena",    boon: "Cursed Wisdom" },
  { name: "Ares",      boon: "War's Toll" },
  { name: "Aphrodite", boon: "Heart's Discord" },
  { name: "Apollo",    boon: "Blinding Pride" },
  { name: "Artemis",   boon: "Moon's Madness" },
  { name: "Hephaestus", boon: "Forge's Flaw" },
  { name: "Hermes",    boon: "Chaotic Speed" },
  { name: "Dionysus",  boon: "Eternal Hangover" },
  { name: "Demeter",   boon: "Withering Touch" },
  { name: "Hera",      boon: "Royal Tax" },
  { name: "Hades",     boon: "Soul Burden" }
];

const GOD_CONFIG = {
  Zeus:      { health: 150, damage: 20, shield: 40, bullets: 12, bulletReload: 900, shieldReload: 4500, zoneColor: 0xffd700 },
  Poseidon:  { health: 170, damage: 15, shield: 45, bullets: 14, bulletReload: 800, shieldReload: 4000, zoneColor: 0x1e90ff },
  Athena:    { health: 130, damage: 12, shield: 55, bullets: 15, bulletReload: 700, shieldReload: 3500, zoneColor: 0xc0c0c0 },
  Ares:      { health: 180, damage: 30, shield: 20, bullets: 8,  bulletReload: 1100, shieldReload: 5500, zoneColor: 0xff4500 },
  Aphrodite: { health: 120, damage: 10, shield: 60, bullets: 16, bulletReload: 600, shieldReload: 3000, zoneColor: 0xff69b4 },
  Apollo:    { health: 130, damage: 18, shield: 35, bullets: 12, bulletReload: 900, shieldReload: 4500, zoneColor: 0xffff66 },
  Artemis:   { health: 125, damage: 16, shield: 30, bullets: 12, bulletReload: 850, shieldReload: 4250, zoneColor: 0x66ff66 },
  Hephaestus:{ health: 200, damage: 22, shield: 25, bullets: 10, bulletReload: 1200, shieldReload: 6000, zoneColor: 0xcd853f },
  Hermes:    { health: 130, damage: 14, shield: 40, bullets: 14, bulletReload: 750, shieldReload: 3750, zoneColor: 0x3cb371 },
  Dionysus:  { health: 140, damage: 13, shield: 45, bullets: 12, bulletReload: 900, shieldReload: 4500, zoneColor: 0xba55d3 },
  Demeter:   { health: 150, damage: 12, shield: 50, bullets: 15, bulletReload: 800, shieldReload: 4000, zoneColor: 0x20b2aa },
  Hera:      { health: 160, damage: 15, shield: 70, bullets: 16, bulletReload: 700, shieldReload: 3500, zoneColor: 0xff69b4 },
  Hades:     { health: 160, damage: 24, shield: 35, bullets: 10, bulletReload: 1000, shieldReload: 5000, zoneColor: 0x8b008b }
};

// We'll generate dynamic textures for combatants.
// For non-Hades, a polygon texture; for Hades, a circular texture.
const GOD_SPRITES = {}; // Filled in preload.

// Helper: create a polygon texture.
function createPolygonTexture(scene, key, sides, radius, color) {
  let graphics = scene.make.graphics({ x: 0, y: 0, add: false });
  let angleStep = (2 * Math.PI) / sides;
  let points = [];
  for (let i = 0; i < sides; i++) {
    let angle = i * angleStep - Math.PI/2; // Start upward.
    let x = radius * Math.cos(angle) + radius;
    let y = radius * Math.sin(angle) + radius;
    points.push(new Phaser.Geom.Point(x, y));
  }
  graphics.fillStyle(color, 1);
  graphics.beginPath();
  graphics.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    graphics.lineTo(points[i].x, points[i].y);
  }
  graphics.closePath();
  graphics.fillPath();
  graphics.generateTexture(key, radius * 2, radius * 2);
  graphics.destroy();
}

// Helper: create a circular texture.
function createCircleTexture(scene, key, radius, color) {
  let graphics = scene.make.graphics({ x: 0, y: 0, add: false });
  graphics.fillStyle(color, 1);
  graphics.fillCircle(radius, radius, radius);
  graphics.generateTexture(key, radius * 2, radius * 2);
  graphics.destroy();
}

// --- Constants for input ---
const BUTTONS = { A: 0, B: 1, X: 2, Y: 3 };
const PLAYER_SPEED = 100;
const ENEMY_SPEED = 50;

/* ======================================================================
   Object Pool (Simple Stub)
   ====================================================================== */
class Pool {
  constructor(createFn) {
    this.createFn = createFn;
    this.pool = [];
  }
  get(...args) {
    return (this.pool.length > 0) ? this.pool.pop() : this.createFn(...args);
  }
  release(obj) {
    this.pool.push(obj);
  }
}

/* ======================================================================
   EasyStar Setup (Stub)
   ====================================================================== */
const easyStar = new EasyStar.js();
const gridCols = 48, gridRows = 36;
const grid = [];
for (let y = 0; y < gridRows; y++) {
  const col = [];
  for (let x = 0; x < gridCols; x++) { col.push(0); }
  grid.push(col);
}
easyStar.setGrid(grid);
easyStar.setAcceptableTiles([0]);
// TODO: Add obstacles and use easyStar.findPath() in enemy AI

/* ======================================================================
   ProjectileAttack Class (For Long-Range Attacks)
   ====================================================================== */
class ProjectileAttack {
  constructor(scene, x, y, texture, velX, velY, damage, owner) {
    this.scene = scene;
    if (!owner.lastFacing) { owner.lastFacing = { x: 1, y: 0 }; }
    const offset = 30;
    x = x + owner.lastFacing.x * offset;
    y = y + owner.lastFacing.y * offset;
    this.sprite = scene.add.sprite(x, y, texture);
    this.sprite.setScale(0.5);
    this.velX = velX;
    this.velY = velY;
    this.damage = damage;
    this.owner = owner;
    this.lifetime = 2000;
  }
  update(delta) {
    const dt = delta / 1000;
    this.sprite.x += this.velX * dt;
    this.sprite.y += this.velY * dt;
    this.lifetime -= delta;
    if (this.lifetime <= 0) {
      this.destroy();
      return false;
    }
    return true;
  }
  getBounds() {
    return this.sprite.getBounds();
  }
  destroy() {
    this.sprite.destroy();
  }
}

/* ======================================================================
   PieZone Class (For Circular Arena Slices with Gradients)
   ====================================================================== */
class PieZone {
  constructor(scene, centerX, centerY, radius, startAngle, endAngle, god, zoneColor) {
    this.scene = scene;
    this.centerX = centerX;
    this.centerY = centerY;
    this.radius = radius;
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.god = god;
    this.zoneColor = zoneColor;
    this.defaultColor = 0x222222; // Darker default background.
    this.graphics = scene.add.graphics();
    this.text = scene.add.text(0, 0, god, { fontFamily: 'monospace', fontSize: '14px', fill: '#fff' });
    this.updateDisplay([]);
  }
  contains(x, y) {
    let dx = x - this.centerX;
    let dy = y - this.centerY;
    let dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > this.radius) return false;
    let angle = Math.atan2(dy, dx);
    if (angle < 0) angle += 2 * Math.PI;
    return (this.startAngle > this.endAngle)
      ? (angle >= this.startAngle || angle < this.endAngle)
      : (angle >= this.startAngle && angle < this.endAngle);
  }
  updateDisplay(players) {
    this.graphics.clear();
    let active = players.some(player => player.god === this.god && this.contains(player.sprite.x, player.sprite.y));
    if (active) {
      let light = lightenColor(this.zoneColor, 0.3);
      this.graphics.fillGradientStyle(light, this.zoneColor, this.zoneColor, light, 1);
    } else {
      let dark = darkenColor(this.zoneColor, 0.3);
      this.graphics.fillGradientStyle(dark, this.zoneColor, this.zoneColor, dark, 1);
    }
    this.graphics.slice(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, false);
    this.graphics.fillPath();
    this.graphics.lineStyle(2, 0xffffff, 1);
    this.graphics.slice(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, false);
    this.graphics.strokePath();
    let midAngle = (this.startAngle + this.endAngle) / 2;
    let labelRadius = this.radius * 0.5;
    let tx = this.centerX + labelRadius * Math.cos(midAngle) - 20;
    let ty = this.centerY + labelRadius * Math.sin(midAngle) - 10;
    if (active) {
      this.text.setText(this.god + "\n" + GOD_ICONS[this.god] + " " + GOD_BOONS[this.god]);
    } else {
      this.text.setText(this.god);
    }
    this.text.setPosition(tx, ty);
  }
}

/* ======================================================================
   MeleeAttack Class (Temporary Hitbox for Melee Attacks)
   ====================================================================== */
class MeleeAttack {
  constructor(scene, x, y, width, height, rotation, damage, owner) {
    this.scene = scene;
    this.hitbox = scene.add.rectangle(x, y, width, height, 0xff0000, 0.5);
    this.hitbox.rotation = rotation;
    this.damage = damage;
    this.owner = owner;
    this.lifetime = 200;
    // TODO: Add particle effects.
  }
  update(delta) {
    this.lifetime -= delta;
    if (this.lifetime <= 0) {
      this.destroy();
      return false;
    }
    return true;
  }
  getBounds() {
    return this.hitbox.getBounds();
  }
  destroy() {
    this.hitbox.destroy();
  }
}

/* ======================================================================
   PowerUp Class (Temporary Boosts)
   ====================================================================== */
class PowerUp {
  constructor(scene, x, y, type) {
    this.scene = scene;
    this.type = type;
    this.sprite = scene.add.sprite(x, y, "projectile");
    this.sprite.setScale(0.5);
    this.lifetime = 10000;
    this.label = scene.add.text(x, y - 20, "Shield +20", { fontSize: '12px', fill: '#fff' });
  }
  update(delta) {
    this.lifetime -= delta;
    this.label.setPosition(this.sprite.x, this.sprite.y - 20);
    if (this.lifetime <= 0) {
      this.destroy();
      return false;
    }
    return true;
  }
  getBounds() {
    return this.sprite.getBounds();
  }
  destroy() {
    this.sprite.destroy();
    this.label.destroy();
  }
}

/* ======================================================================
   Player Class Definition
   ====================================================================== */
class Player {
  constructor(scene, x, y, playerIndex, shapeSides) {
    this.scene = scene;
    this.playerIndex = playerIndex;
    this.god = Phaser.Utils.Array.GetRandom(GODS).name;
    let cfg = GOD_CONFIG[this.god] || { health: 100, damage: 10, shield: 20, bullets: 10, bulletReload: 1000, shieldReload: 5000 };
    this.maxHealth = cfg.health;
    this.health = cfg.health;
    this.damage = cfg.damage;
    this.maxShield = cfg.shield;
    this.shield = cfg.shield;
    this.maxBullets = cfg.bullets;
    this.currentBullets = cfg.bullets;
    this.reloadRate = cfg.bulletReload;
    this.shieldReloadRate = cfg.shieldReload;
    this.lastReloadTime = 0;
    this.lastShieldReloadTime = 0;
    this.speed = PLAYER_SPEED;
    // Use a polygon texture for non-Hades; for Hades, use a circle.
    if (this.god === "Hades") {
      this.sprite = scene.add.sprite(x, y, "circle_hades");
    } else {
      this.sprite = scene.add.sprite(x, y, "poly_" + shapeSides);
    }
    this.sprite.setScale(0.5);
    // Tint the sprite with its god's zone color.
    this.sprite.setTint(GOD_CONFIG[this.god].zoneColor);
    this.nameText = scene.add.text(x - 20, y - 70, "P" + playerIndex + ": " + this.god, { fontSize: '12px', fill: '#fff' });
    this.bulletText = scene.add.text(x - 20, y - 55, "Ammo: " + this.currentBullets, { fontSize: '12px', fill: '#fff' });
    this.healthBar = scene.add.graphics();
    this.gamepad = null;
    this.keys = null;
    this.lastAttackTime = 0;
    this.attackCooldown = 500;
    this.lastFacing = { x: 1, y: 0 };
  }
  update() {
    const delta = this.scene.game.loop.delta;
    const deltaTime = delta / 1000;
    const currentTime = this.scene.time.now;
    if (currentTime - this.lastReloadTime > this.reloadRate && this.currentBullets < this.maxBullets) {
      this.currentBullets++;
      this.lastReloadTime = currentTime;
    }
    if (currentTime - this.lastShieldReloadTime > this.shieldReloadRate && this.shield < this.maxShield) {
      this.shield++;
      this.lastShieldReloadTime = currentTime;
    }
    this.bulletText.setText("Ammo: " + this.currentBullets);
    this.bulletText.setPosition(this.sprite.x - 20, this.sprite.y - 55);
    
    if (!this.gamepad) {
      if (!this.keys) {
        if (this.playerIndex === 0) {
          this.keys = this.scene.input.keyboard.addKeys({
            left: Phaser.Input.Keyboard.KeyCodes.LEFT,
            right: Phaser.Input.Keyboard.KeyCodes.RIGHT,
            up: Phaser.Input.Keyboard.KeyCodes.UP,
            down: Phaser.Input.Keyboard.KeyCodes.DOWN,
            sprint: Phaser.Input.Keyboard.KeyCodes.SHIFT,
            melee1: Phaser.Input.Keyboard.KeyCodes.SPACE,
            melee2: Phaser.Input.Keyboard.KeyCodes.Q,
            projectile: Phaser.Input.Keyboard.KeyCodes.E
          });
        } else if (this.playerIndex === 1) {
          this.keys = this.scene.input.keyboard.addKeys({
            left: Phaser.Input.Keyboard.KeyCodes.A,
            right: Phaser.Input.Keyboard.KeyCodes.D,
            up: Phaser.Input.Keyboard.KeyCodes.W,
            down: Phaser.Input.Keyboard.KeyCodes.S,
            sprint: Phaser.Input.Keyboard.KeyCodes.CONTROL,
            melee1: Phaser.Input.Keyboard.KeyCodes.F,
            melee2: Phaser.Input.Keyboard.KeyCodes.G,
            projectile: Phaser.Input.Keyboard.KeyCodes.H
          });
        } else if (this.playerIndex === 2) {
          this.keys = this.scene.input.keyboard.addKeys({
            left: Phaser.Input.Keyboard.KeyCodes.J,
            right: Phaser.Input.Keyboard.KeyCodes.L,
            up: Phaser.Input.Keyboard.KeyCodes.I,
            down: Phaser.Input.Keyboard.KeyCodes.K,
            sprint: Phaser.Input.Keyboard.KeyCodes.U,
            melee1: Phaser.Input.Keyboard.KeyCodes.O,
            melee2: Phaser.Input.Keyboard.KeyCodes.P,
            projectile: Phaser.Input.Keyboard.KeyCodes.OPEN_BRACKET
          });
        } else if (this.playerIndex === 3) {
          this.keys = this.scene.input.keyboard.addKeys({
            left: Phaser.Input.Keyboard.KeyCodes.NUMPAD_4,
            right: Phaser.Input.Keyboard.KeyCodes.NUMPAD_6,
            up: Phaser.Input.Keyboard.KeyCodes.NUMPAD_8,
            down: Phaser.Input.Keyboard.KeyCodes.NUMPAD_2,
            sprint: Phaser.Input.Keyboard.KeyCodes.NUMPAD_0,
            melee1: Phaser.Input.Keyboard.KeyCodes.NUMPAD_1,
            melee2: Phaser.Input.Keyboard.KeyCodes.NUMPAD_3,
            projectile: Phaser.Input.Keyboard.KeyCodes.NUMPAD_5
          });
        }
      }
      let vx = 0, vy = 0;
      if (this.keys.left.isDown) { vx = -this.speed; }
      else if (this.keys.right.isDown) { vx = this.speed; }
      if (this.keys.up.isDown) { vy = -this.speed; }
      else if (this.keys.down.isDown) { vy = this.speed; }
      if (this.keys.sprint.isDown) { vx *= 1.5; vy *= 1.5; }
      if (vx !== 0 || vy !== 0) {
        let mag = Math.sqrt(vx * vx + vy * vy);
        this.lastFacing.x = vx / mag;
        this.lastFacing.y = vy / mag;
      }
      this.sprite.x += vx * deltaTime;
      this.sprite.y += vy * deltaTime;
      
      if (this.keys.melee1.isDown && (currentTime - this.lastAttackTime > this.attackCooldown) && this.currentBullets > 0) {
        this.meleeAttackRegular();
        this.lastAttackTime = currentTime;
      }
      if (this.keys.melee2.isDown && (currentTime - this.lastAttackTime > this.attackCooldown) && this.currentBullets > 0) {
        this.meleeAttackSpin();
        this.lastAttackTime = currentTime;
      }
      if (this.keys.projectile.isDown && (currentTime - this.lastAttackTime > this.attackCooldown) && this.currentBullets > 0) {
        this.projectileAttack();
        this.lastAttackTime = currentTime;
      }
    } else {
      let axisH = (this.gamepad.axes.length > 0) ? this.gamepad.axes[0].getValue() : 0;
      let axisV = (this.gamepad.axes.length > 1) ? this.gamepad.axes[1].getValue() : 0;
      let vx = axisH * this.speed;
      let vy = axisV * this.speed;
      if (this.gamepad.buttons[BUTTONS.A].pressed) { vx *= 1.5; vy *= 1.5; }
      if (Math.abs(axisH) > 0.1 || Math.abs(axisV) > 0.1) {
        let mag = Math.sqrt(axisH*axisH+axisV*axisV);
        this.lastFacing.x = axisH/mag;
        this.lastFacing.y = axisV/mag;
      }
      this.sprite.x += vx * deltaTime;
      this.sprite.y += vy * deltaTime;
      
      if (currentTime - this.lastAttackTime > this.attackCooldown && this.currentBullets > 0) {
        if (this.gamepad.buttons[BUTTONS.B].pressed) {
          this.meleeAttackRegular();
          this.lastAttackTime = currentTime;
        } else if (this.gamepad.buttons[BUTTONS.X].pressed) {
          this.meleeAttackSpin();
          this.lastAttackTime = currentTime;
        } else if (this.gamepad.buttons[BUTTONS.Y].pressed) {
          this.projectileAttack();
          this.lastAttackTime = currentTime;
        }
      }
    }
    
    // Clamp position within the arena.
    let dx = this.sprite.x - ARENA_CENTER.x;
    let dy = this.sprite.y - ARENA_CENTER.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > ARENA_RADIUS) {
      this.sprite.x = ARENA_CENTER.x + (dx/dist) * ARENA_RADIUS;
      this.sprite.y = ARENA_CENTER.y + (dy/dist) * ARENA_RADIUS;
    }
    
    this.sprite.rotation = Math.atan2(this.lastFacing.y, this.lastFacing.x) + Math.PI/2;
    this.nameText.setText("P" + this.playerIndex + ": " + this.god);
    this.nameText.setPosition(this.sprite.x - 20, this.sprite.y - 70);
    this.updateHealthBar();
  }
  
  meleeAttackRegular() {
    if (this.currentBullets <= 0) return;
    this.currentBullets--;
    this.scene.spawnMeleeAttack(this.sprite.x, this.sprite.y, "regular", this);
  }
  
  meleeAttackSpin() {
    if (this.currentBullets <= 0) return;
    this.currentBullets--;
    this.scene.spawnMeleeAttack(this.sprite.x, this.sprite.y, "spin", this);
  }
  
  projectileAttack() {
    if (this.currentBullets <= 0) return;
    this.currentBullets--;
    this.scene.spawnProjectileAttack(this.sprite.x, this.sprite.y, this, this.lastFacing.x, this.lastFacing.y);
  }
  
  updateHealthBar() {
    this.healthBar.clear();
    const barWidth = 40, barHeight = 6;
    let healthPercent = Phaser.Math.Clamp(this.health / this.maxHealth, 0, 1);
    this.healthBar.fillStyle(0xff0000);
    this.healthBar.fillRect(this.sprite.x - barWidth/2, this.sprite.y - 80, barWidth, barHeight);
    this.healthBar.fillStyle(0x00ff00);
    this.healthBar.fillRect(this.sprite.x - barWidth/2, this.sprite.y - 80, barWidth * healthPercent, barHeight);
    if (this.shield > 0) {
      this.healthBar.lineStyle(4, 0x0000ff, 1);
      this.healthBar.strokeCircle(this.sprite.x, this.sprite.y, 30);
    }
  }
  
  destroy() {
    this.sprite.destroy();
    this.nameText.destroy();
    this.bulletText.destroy();
    this.healthBar.destroy();
  }
}

/* ======================================================================
   Enemy Class Definition
   ====================================================================== */
class Enemy {
  constructor(scene, x, y, enemyIndex, shapeSides) {
    this.scene = scene;
    this.enemyIndex = enemyIndex;
    let availableGods = GODS.filter(g => g.name !== "Hades");
    this.god = Phaser.Utils.Array.GetRandom(availableGods).name;
    let cfg = GOD_CONFIG[this.god] || { health: 100, damage: 10, shield: 20, bullets: 10, bulletReload: 1000, shieldReload: 5000 };
    this.maxHealth = cfg.health;
    this.health = cfg.health;
    this.damage = cfg.damage;
    this.maxShield = cfg.shield;
    this.shield = cfg.shield;
    this.maxBullets = cfg.bullets;
    this.currentBullets = cfg.bullets;
    this.reloadRate = cfg.bulletReload;
    this.shieldReloadRate = cfg.shieldReload;
    this.lastReloadTime = 0;
    this.lastShieldReloadTime = 0;
    this.speed = ENEMY_SPEED;
    this.attackCooldown = 1000;
    this.lastAttackTime = 0;
    this.homeZone = this.scene.pieZones.find(z => z.god === this.god);
    this.state = "patrol";
    this.stateTime = 0;
    this.patrolDirection = { x: Math.random()*2-1, y: Math.random()*2-1 };
    if (this.god === "Hades") {
      this.sprite = scene.add.sprite(x, y, "circle_hades");
    } else {
      this.sprite = scene.add.sprite(x, y, "poly_" + shapeSides);
    }
    this.sprite.setScale(0.5);
    this.sprite.setTint(GOD_CONFIG[this.god].zoneColor);
    this.nameText = scene.add.text(x - 10, y - 30, "E" + enemyIndex + ": " + this.god, { fontSize: '12px', fill: '#fff' });
    this.healthBar = scene.add.graphics();
  }
  
  update(time, delta) {
    const deltaTime = delta / 1000;
    this.stateTime += delta;
    if (time - this.lastReloadTime > this.reloadRate && this.currentBullets < this.maxBullets) {
      this.currentBullets++;
      this.lastReloadTime = time;
    }
    
    // Find nearest target (players or other enemies).
    let nearest = null, minDist = Infinity;
    let allTargets = this.scene.players.concat(this.scene.enemies.filter(e => e !== this));
    for (let target of allTargets) {
      let dx = target.sprite.x - this.sprite.x;
      let dy = target.sprite.y - this.sprite.y;
      let dist = Math.sqrt(dx*dx+dy*dy);
      if (dist < minDist) { minDist = dist; nearest = target; }
    }
    
    if (this.health < this.maxHealth * 0.3) {
      this.state = "retreat";
    } else if (this.scene.meleeAttacks.some(a => Phaser.Geom.Intersects.RectangleToRectangle(a.getBounds(), this.sprite.getBounds()))) {
      this.state = "dodge";
    } else if (nearest && minDist < 500) {
      this.state = "chase";
    } else if (!this.homeZone || !this.homeZone.contains(this.sprite.x, this.sprite.y)) {
      this.state = "home";
    } else {
      this.state = "patrol";
    }
    
    if (this.state === "home" && this.homeZone) {
      let dx = this.homeZone.centerX - this.sprite.x;
      let dy = this.homeZone.centerY - this.sprite.y;
      let mag = Math.sqrt(dx*dx+dy*dy);
      if (mag > 0) {
        this.sprite.x += (dx/mag) * this.speed * deltaTime;
        this.sprite.y += (dy/mag) * this.speed * deltaTime;
      }
    } else if (this.state === "patrol") {
      if (this.stateTime > 2000) {
        this.patrolDirection = { x: Math.random()*2-1, y: Math.random()*2-1 };
        this.stateTime = 0;
      }
      this.sprite.x += this.patrolDirection.x * this.speed * deltaTime;
      this.sprite.y += this.patrolDirection.y * this.speed * deltaTime;
    } else if (this.state === "chase" && nearest) {
      let dx = nearest.sprite.x - this.sprite.x;
      let dy = nearest.sprite.y - this.sprite.y;
      let mag = Math.sqrt(dx*dx+dy*dy);
      if (mag > 0) {
        this.sprite.x += (dx/mag) * this.speed * deltaTime;
        this.sprite.y += (dy/mag) * this.speed * deltaTime;
      }
      if (minDist < 300 && time - this.lastAttackTime > this.attackCooldown && this.currentBullets > 0) {
        this.currentBullets--;
        let dirX = dx/mag, dirY = dy/mag;
        this.scene.spawnProjectileAttack(this.sprite.x, this.sprite.y, this, dirX, dirY);
        this.lastAttackTime = time;
      }
    } else if (this.state === "retreat") {
      if (nearest) {
        let dx = this.sprite.x - nearest.sprite.x;
        let dy = this.sprite.y - nearest.sprite.y;
        let mag = Math.sqrt(dx*dx+dy*dy);
        if (mag > 0) {
          this.sprite.x += (dx/mag) * this.speed * deltaTime;
          this.sprite.y += (dy/mag) * this.speed * deltaTime;
        }
      }
    } else if (this.state === "dodge") {
      this.sprite.x += this.speed * deltaTime;
    }
    
    // Clamp within arena.
    let dx = this.sprite.x - ARENA_CENTER.x;
    let dy = this.sprite.y - ARENA_CENTER.y;
    let dist = Math.sqrt(dx*dx+dy*dy);
    if (dist > ARENA_RADIUS) {
      this.sprite.x = ARENA_CENTER.x + (dx/dist) * ARENA_RADIUS;
      this.sprite.y = ARENA_CENTER.y + (dy/dist) * ARENA_RADIUS;
    }
    
    this.updateHealthBar();
    this.nameText.setPosition(this.sprite.x - 10, this.sprite.y - 30);
    if (this.health <= 0) {
      this.sprite.destroy();
      this.nameText.destroy();
      this.healthBar.destroy();
      this.scene.enemies = this.scene.enemies.filter(e => e !== this);
    }
  }
  
  updateHealthBar() {
    this.healthBar.clear();
    const barWidth = 30, barHeight = 5;
    let healthPercent = Phaser.Math.Clamp(this.health / this.maxHealth, 0, 1);
    this.healthBar.fillStyle(0xff0000);
    this.healthBar.fillRect(this.sprite.x - barWidth/2, this.sprite.y - 40, barWidth, barHeight);
    this.healthBar.fillStyle(0x00ff00);
    this.healthBar.fillRect(this.sprite.x - barWidth/2, this.sprite.y - 40, barWidth * healthPercent, barHeight);
  }
  
  destroy() {
    this.sprite.destroy();
    this.nameText.destroy();
    this.bulletText.destroy();
    this.healthBar.destroy();
  }
}

/* ======================================================================
   Main Scene (Game World)
   ====================================================================== */
class MainScene extends Phaser.Scene {
  constructor() {
    super('MainScene');
  }
  
  preload() {
    // Generate polygon textures for non-Hades (sides 3 to 14).
    for (let sides = 3; sides <= 14; sides++) {
      let key = "poly_" + sides;
      // Base texture in white; tint will be applied later.
      createPolygonTexture(this, key, sides, 32, 0xffffff);
    }
    // Generate a circular texture for Hades.
    createCircleTexture(this, "circle_hades", 32, 0xffffff);
    // Create a placeholder projectile texture.
    let projGraphics = this.make.graphics({ x: 0, y: 0, add: false });
    projGraphics.fillStyle(0xffffff, 1);
    projGraphics.fillRect(0, 0, 16, 16);
    projGraphics.generateTexture("projectile", 16, 16);
    projGraphics.destroy();
  }
  
  create() {
    // Set a much darker background.
    this.cameras.main.setBackgroundColor(0x111111);
    this.arenaCenter = ARENA_CENTER;
    this.arenaRadius = ARENA_RADIUS;
    
    // Create the GodLight title (fixed to camera).
    let asciiArt =
`   ____       _     _     _     _ _ 
  / ___| ___ | |__ (_)___| |__ (_) |
 | |  _ / _ \\| '_ \\| / __| '_ \\| | |
 | |_| | (_) | |_) | \\__ \\ | | | | |
  \\____|\\___/|_.__/|_|___/_| |_|_|_|`;
    let titleText = this.add.text(GAME_WIDTH/2 - 300, 10, asciiArt, {
      fontFamily: 'monospace',
      fontSize: '20px',
      fill: '#fff'
    });
    titleText.setDepth(1000);
    titleText.setScrollFactor(0);
    
    // Create a dedicated HUD panel at the bottom.
    this.hudPanel = this.add.rectangle(10, GAME_HEIGHT - 100, GAME_WIDTH - 20, 90, 0x000000, 0.5)
      .setOrigin(0, 0)
      .setDepth(1000);
    this.hudText = this.add.text(20, GAME_HEIGHT - 90, "", { fontSize: '16px', fill: '#fff' })
      .setDepth(1000);
    
    // Create central Hades realm.
    this.hadesCircle = this.add.circle(ARENA_CENTER.x, ARENA_CENTER.y, 75, GOD_CONFIG["Hades"].zoneColor, 0.5);
    
    // Create pie zones for gods except Hades.
    this.pieZones = [];
    let centerX = ARENA_CENTER.x, centerY = ARENA_CENTER.y;
    let godsForZones = GODS.filter(g => g.name !== "Hades");
    const numZones = godsForZones.length;
    for (let i = 0; i < numZones; i++) {
      let startAngle = i * (2 * Math.PI / numZones);
      let endAngle = (i + 1) * (2 * Math.PI / numZones);
      let god = godsForZones[i].name;
      let zoneColor = GOD_CONFIG[god] ? GOD_CONFIG[god].zoneColor : 0xffffff;
      let zone = new PieZone(this, centerX, centerY, this.arenaRadius, startAngle, endAngle, god, zoneColor);
      this.pieZones.push(zone);
    }
    
    // Initialize arrays.
    this.meleeAttacks = [];
    this.projectiles = [];
    this.powerUps = [];
    
    // Spawn exactly 13 combatants (one per god).
    // First 4 gods are player-controlled; the rest are AI.
    this.players = [];
    this.enemies = [];
    let nonHadesIndex = 0;
    for (let i = 0; i < GODS.length; i++) {
      let godName = GODS[i].name;
      let spawnX, spawnY;
      if (godName === "Hades") {
        let angle = Phaser.Math.FloatBetween(0, 2 * Math.PI);
        let r = Phaser.Math.FloatBetween(0, 75);
        spawnX = ARENA_CENTER.x + r * Math.cos(angle);
        spawnY = ARENA_CENTER.y + r * Math.sin(angle);
      } else {
        let zone = this.pieZones.find(z => z.god === godName);
        if (zone) {
          let angle = Phaser.Math.FloatBetween(zone.startAngle, zone.endAngle);
          let r = Phaser.Math.FloatBetween(0, zone.radius * 0.8);
          spawnX = zone.centerX + r * Math.cos(angle);
          spawnY = zone.centerY + r * Math.sin(angle);
        } else {
          spawnX = Phaser.Math.Between(50, GAME_WIDTH - 50);
          spawnY = Phaser.Math.Between(50, GAME_HEIGHT - 50);
        }
      }
      if (i < 4) {
        let shapeSides = (godName === "Hades") ? 0 : (3 + nonHadesIndex++);
        let player = new Player(this, spawnX, spawnY, i, shapeSides);
        player.god = godName;
        if (godName === "Hades") {
          player.sprite.setTexture("circle_hades");
        } else {
          player.sprite.setTexture("poly_" + shapeSides);
        }
        player.homeZone = (godName === "Hades") ? this.hadesCircle : this.pieZones.find(z => z.god === godName);
        let cfg = GOD_CONFIG[godName];
        player.maxHealth = cfg.health;
        player.health = cfg.health;
        player.damage = cfg.damage;
        player.maxShield = cfg.shield;
        player.shield = cfg.shield;
        player.maxBullets = cfg.bullets;
        player.currentBullets = cfg.bullets;
        this.players.push(player);
      } else {
        let shapeSides = (godName === "Hades") ? 0 : (3 + nonHadesIndex++);
        let enemy = new Enemy(this, spawnX, spawnY, i, shapeSides);
        enemy.god = godName;
        if (godName === "Hades") {
          enemy.sprite.setTexture("circle_hades");
        } else {
          enemy.sprite.setTexture("poly_" + shapeSides);
        }
        enemy.homeZone = this.pieZones.find(z => z.god === godName);
        let cfg = GOD_CONFIG[godName];
        enemy.maxHealth = cfg.health;
        enemy.health = cfg.health;
        enemy.damage = cfg.damage;
        enemy.maxShield = cfg.shield;
        enemy.shield = cfg.shield;
        enemy.maxBullets = cfg.bullets;
        enemy.currentBullets = cfg.bullets;
        this.enemies.push(enemy);
      }
    }
    
    // Spawn power-ups INSIDE the arena.
    this.time.addEvent({
      delay: 15000,
      callback: () => {
        // Generate random angle and radius within the arena.
        let angle = Phaser.Math.FloatBetween(0, 2*Math.PI);
        let r = Math.sqrt(Math.random()) * this.arenaRadius;
        let puX = ARENA_CENTER.x + r * Math.cos(angle);
        let puY = ARENA_CENTER.y + r * Math.sin(angle);
        let powerUp = new PowerUp(this, puX, puY, "shield");
        this.powerUps.push(powerUp);
      },
      loop: true
    });
    
    // Add help icon.
    this.helpIcon = this.add.text(GAME_WIDTH - 30, 10, "?", { fontSize: '24px', fill: '#fff' });
    this.helpIcon.setInteractive();
    this.helpIcon.on('pointerdown', () => {
      if (this.scene.isActive('HelpScene')) {
        this.scene.stop('HelpScene');
      } else {
        this.scene.launch('HelpScene', { previousScene: 'MainScene' });
      }
    });
    this.input.keyboard.on('keydown', (event) => {
      if (event.key === '?') {
        if (this.scene.isActive('HelpScene')) {
          this.scene.stop('HelpScene');
        } else {
          this.scene.launch('HelpScene', { previousScene: 'MainScene' });
        }
      }
    });
    
    // Gamepad assignment.
    if (this.input.gamepad.total > 0) {
      this.input.gamepad.gamepads.forEach((pad, idx) => {
        if (this.players[idx] && !this.players[idx].gamepad) {
          this.players[idx].gamepad = pad;
        }
      });
    }
    this.input.gamepad.on('connected', (pad) => {
      this.players.forEach((player, idx) => {
        if (!player.gamepad && this.input.gamepad.gamepads[idx]) {
          player.gamepad = this.input.gamepad.gamepads[idx];
        }
      });
    });
  }
  
  spawnMeleeAttack(x, y, attackType, shooter) {
    let offset = 0, width = 0, height = 0, damageMultiplier = 1;
    if (attackType === "regular") {
      offset = 20;
      width = 30; height = 20;
      damageMultiplier = 1;
    } else if (attackType === "spin") {
      offset = 0;
      width = 50; height = 50;
      damageMultiplier = 0.7;
    }
    let attackX = x, attackY = y;
    if (offset > 0) {
      attackX = x + shooter.lastFacing.x * offset;
      attackY = y + shooter.lastFacing.y * offset;
    }
    let rotation = (attackType === "spin") ? 0 : Math.atan2(shooter.lastFacing.y, shooter.lastFacing.x);
    this.spawnMeleeAttackHitbox(attackX, attackY, width, height, rotation, shooter.damage * damageMultiplier, shooter);
  }
  
  spawnMeleeAttackHitbox(x, y, width, height, rotation, damage, shooter) {
    let melee = new MeleeAttack(this, x, y, width, height, rotation, damage, shooter);
    this.meleeAttacks.push(melee);
    // TODO: Add particle effects.
  }
  
  spawnProjectileAttack(x, y, shooter, dirX, dirY) {
    let speed = 500;
    let mag = Math.sqrt(dirX * dirX + dirY * dirY);
    if (mag === 0) { dirX = shooter.lastFacing.x; dirY = shooter.lastFacing.y; }
    else { dirX /= mag; dirY /= mag; }
    let velX = dirX * speed;
    let velY = dirY * speed;
    let damage = shooter.damage * 1.2;
    let projectile = new ProjectileAttack(this, x, y, "projectile", velX, velY, damage, shooter);
    this.projectiles.push(projectile);
  }
  
  updateProjectileAttacks(delta) {
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      let proj = this.projectiles[i];
      if (!proj.update(delta)) {
        this.projectiles.splice(i, 1);
      } else {
        let allTargets = this.players.concat(this.enemies);
        for (let target of allTargets) {
          if (target !== proj.owner &&
              Phaser.Geom.Intersects.RectangleToRectangle(proj.getBounds(), target.sprite.getBounds())) {
            let dmg = proj.damage;
            if (target.shield > 0) {
              let remainder = dmg - target.shield;
              target.shield = Math.max(0, target.shield - dmg);
              if (remainder > 0) {
                target.health = Math.max(0, target.health - remainder);
              }
            } else {
              target.health = Math.max(0, target.health - dmg);
            }
            proj.destroy();
            this.projectiles.splice(i, 1);
            break;
          }
        }
      }
    }
  }
  
  updatePowerUps(delta) {
    for (let i = this.powerUps.length - 1; i >= 0; i--) {
      let pu = this.powerUps[i];
      if (!pu.update(delta)) {
        this.powerUps.splice(i, 1);
      } else {
        this.players.forEach(player => {
          if (Phaser.Geom.Intersects.RectangleToRectangle(pu.getBounds(), player.sprite.getBounds())) {
            player.shield += 20;
            pu.destroy();
            this.powerUps.splice(i, 1);
          }
        });
      }
    }
  }
  
  update(time, delta) {
    // Update pie zones with current player positions.
    this.pieZones.forEach(zone => zone.updateDisplay(this.players));
    this.hadesCircle.setPosition(ARENA_CENTER.x, ARENA_CENTER.y);
    
    // Update melee attacks (apply damage to all overlapping targets).
    for (let i = this.meleeAttacks.length - 1; i >= 0; i--) {
      let attack = this.meleeAttacks[i];
      if (!attack.update(delta)) {
        this.meleeAttacks.splice(i, 1);
      } else {
        let allTargets = this.players.concat(this.enemies);
        let hitSomething = false;
        allTargets.forEach(target => {
          if (target !== attack.owner &&
              Phaser.Geom.Intersects.RectangleToRectangle(attack.getBounds(), target.sprite.getBounds())) {
            let dmg = attack.damage;
            if (target.shield > 0) {
              let remainder = dmg - target.shield;
              target.shield = Math.max(0, target.shield - dmg);
              if (remainder > 0) {
                target.health = Math.max(0, target.health - remainder);
              }
            } else {
              target.health = Math.max(0, target.health - dmg);
            }
            hitSomething = true;
          }
        });
        if (hitSomething) {
          attack.destroy();
          this.meleeAttacks.splice(i, 1);
        }
      }
    }
    
    this.updateProjectileAttacks(delta);
    this.updatePowerUps(delta);
    
    // Iterate backward over players.
    for (let i = this.players.length - 1; i >= 0; i--) {
      let player = this.players[i];
      player.update();
      if (player.health <= 0) {
        player.destroy();
        this.players.splice(i, 1);
      }
    }
    // Iterate backward over enemies.
    for (let i = this.enemies.length - 1; i >= 0; i--) {
      let enemy = this.enemies[i];
      enemy.update(time, delta);
      if (enemy.health <= 0) {
        enemy.sprite.destroy();
        enemy.nameText.destroy();
        enemy.healthBar.destroy();
        this.enemies.splice(i, 1);
      }
    }
    
    // Update HUD panel.
    let hudInfo = "Combatants Left:\n";
    let allChars = this.players.concat(this.enemies);
    allChars.forEach((char, idx) => {
      let label = (char.playerIndex !== undefined) ? ("P" + char.playerIndex + ": " + char.god)
                                                  : ("E" + idx + ": " + char.god);
      hudInfo += label + " - HP: " + char.health + " | Shield: " + char.shield + " | Ammo: " + char.currentBullets + "\n";
    });
    this.hudText.setText(hudInfo);
    
    // Win condition: if only one unique god remains.
    if (allChars.length > 0) {
      let uniqueGods = new Set(allChars.map(ch => ch.god));
      if (uniqueGods.size === 1) {
        this.scene.start('WinScene', { god: Array.from(uniqueGods)[0] });
      }
    }
  }
  
  createPlaceholderGraphics(key, width, height, color) {
    let graphics = this.make.graphics({ x: 0, y: 0, add: false });
    graphics.fillStyle(color, 1);
    graphics.fillRect(0, 0, width, height);
    graphics.generateTexture(key, width, height);
    graphics.destroy();
  }
  
  createTriangleTexture(key, width, height, color) {
    let graphics = this.make.graphics({ x: 0, y: 0, add: false });
    graphics.fillStyle(color, 1);
    graphics.beginPath();
    graphics.moveTo(width/2, 0);
    graphics.lineTo(0, height);
    graphics.lineTo(width, height);
    graphics.closePath();
    graphics.fillPath();
    graphics.generateTexture(key, width, height);
    graphics.destroy();
  }
}

/* ======================================================================
   Win Scene Definition
   ====================================================================== */
class WinScene extends Phaser.Scene {
  constructor() {
    super('WinScene');
  }
  init(data) {
    this.winningGod = data.god;
  }
  create() {
    this.cameras.main.setBackgroundColor(0x111111);
    this.add.text(GAME_WIDTH/2 - 200, GAME_HEIGHT/2 - 100, "The " + this.winningGod + " has won!", { fontSize: '48px', fill: '#fff' });
    let btn = document.createElement("button");
    btn.id = "restartBtn";
    btn.textContent = "Restart Game";
    btn.onclick = () => {
      btn.remove();
      this.scene.start('MainScene');
    };
    document.body.appendChild(btn);
  }
}

/* ======================================================================
   Help Scene Definition (Toggle with "?")
   ====================================================================== */
class HelpScene extends Phaser.Scene {
  constructor() {
    super('HelpScene');
  }
  init(data) {
    this.previousScene = data.previousScene || 'MainScene';
  }
  create() {
    this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.7);
    let helpText =
`Keyboard Controls:

Player 0:
  Move: Arrow Keys
  Sprint: SHIFT
  Regular Melee: SPACE
  Spin Melee: Q
  Projectile Attack: E

Player 1:
  Move: W A S D
  Sprint: CONTROL
  Regular Melee: F
  Spin Melee: G
  Projectile Attack: H

Player 2:
  Move: I J K L
  Sprint: U
  Regular Melee: O
  Spin Melee: P
  Projectile Attack: [

Player 3:
  Move: Numpad 8/4/6/2
  Sprint: Numpad 0
  Regular Melee: Numpad 1
  Spin Melee: Numpad 3
  Projectile Attack: Numpad 5

Additional:
  Press "?" to toggle this help screen.`;
    this.add.text(50, 50, helpText, { fontSize: '20px', fill: '#fff', wordWrap: { width: GAME_WIDTH - 100 } });
    this.input.keyboard.once('keydown-?', () => {
      this.scene.stop('HelpScene');
    });
    let closeBtn = document.createElement("button");
    closeBtn.id = "closeHelpBtn";
    closeBtn.textContent = "Close Help";
    closeBtn.onclick = () => {
      closeBtn.remove();
      this.scene.stop('HelpScene');
    };
    document.body.appendChild(closeBtn);
  }
}

/* ======================================================================
   Game Configuration and Initialization
   ====================================================================== */
const config = {
  type: Phaser.AUTO,
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  scene: [MainScene, WinScene, HelpScene],
  parent: 'phaser-example',
  input: { gamepad: true }
};

const game = new Phaser.Game(config);

/*
  Additional Suggestions for More Dynamic Play:

  Enhanced AI:
    - Fully integrate EasyStar.js with a detailed grid of obstacles and call easyStar.findPath() for enemy navigation.
    - Expand enemy state machines to robustly handle patrol, chase, retreat, and dodge behaviors.

  Visual & Audio:
    - Replace placeholder textures with polished assets from OpenGameArt.org or Itch.io, including smooth animations.
    - Use Phaser’s particle emitters to add effects for melee impacts, explosions, and power-up pickups.
    - Incorporate an adaptive soundtrack and context-sensitive sound effects.

  Power-Ups & Special Moves:
    - Enhance the PowerUp class to support multiple boost types (extra speed, damage, etc.) and create unique special moves for each god.

  UI/HUD Enhancements:
    - Build a comprehensive HUD displaying detailed stats (name, HP, shield, ammo) with clear tooltips (using the hudTooltip div) and in-game tutorials.

  Code Organization & Performance:
    - Refactor code into separate modules (Player, Enemy, AI, UI, etc.) for better maintainability.
    - Implement robust object pooling for transient objects (melee hitboxes, projectiles, enemies) to improve performance and reduce garbage collection.

  Further playtesting and balancing will be essential.
*/
</script>
</body>
</html>
