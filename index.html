<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GodLight! - Top-Down Melee Prototype</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    #closeHelpBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      font-size: 20px;
      background-color: #444;
      color: #fff;
      border: none;
      cursor: pointer;
      z-index: 1000;
    }
    #hudTooltip {
      position: absolute;
      padding: 5px 10px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-size: 14px;
      display: none;
      z-index: 1000;
    }
  </style>
  <!-- Load EasyStar.js for pathfinding -->
  <script src="https://cdn.jsdelivr.net/npm/easystarjs@0.4.4/bin/easystar-0.4.4.js"></script>
  <!-- Include Phaser.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
</head>
<body>
<div id="hudTooltip"></div>
<script>
/* ======================================================================
   Global Configuration
   ====================================================================== */
const GAME_WIDTH = 1536;   // Screen: 1536x1152
const GAME_HEIGHT = 1152;

const GODS = [
  { name: "Zeus",      boon: "Lightning Rod – Attracts melee hits, +25% damage to foes." },
  { name: "Poseidon",  boon: "Unstable Tides – Repels nearby characters occasionally." },
  { name: "Athena",    boon: "Cursed Wisdom – Attacks may inadvertently heal foes." },
  { name: "Ares",      boon: "War's Toll – Damage reflects (15%) back to you." },
  { name: "Aphrodite", boon: "Heart's Discord – Healing can harm instead." },
  { name: "Apollo",    boon: "Blinding Pride – Accuracy drops with consecutive hits." },
  { name: "Artemis",   boon: "Moon's Madness – Attacks might misfire on allies." },
  { name: "Hephaestus",boon: "Forge's Flaw – Melee attacks may backfire." },
  { name: "Hermes",    boon: "Chaotic Speed – Movement shifts unpredictably." },
  { name: "Dionysus",  boon: "Eternal Hangover – Kill streaks spin your screen." },
  { name: "Demeter",   boon: "Withering Touch – Nearby areas sap speed." },
  { name: "Hera",      boon: "Royal Tax – Allies near you lose resources." },
  { name: "Hades",     boon: "Soul Burden – Central realm of the underworld." }
];

// Mapping from god names to asset keys (assumed to match file names in assets/ folder)
const GOD_SPRITES = {
  "Zeus": "zeus",
  "Poseidon": "poseidon",
  "Athena": "athena",
  "Ares": "ares",
  "Aphrodite": "aphrodite",
  "Apollo": "apollo",
  "Artemis": "artemis",
  "Hephaestus": "hephaestus",
  "Hermes": "hermes",
  "Dionysus": "dionysus",
  "Demeter": "demeter",
  "Hera": "hera",
  "Hades": "hades"
};

const GOD_CONFIG = {
  Zeus:      { health: 150, damage: 20, shield: 40, bullets: 12, bulletReload: 900, shieldReload: 4500, zoneColor: 0xffd700 },
  Poseidon:  { health: 170, damage: 15, shield: 45, bullets: 14, bulletReload: 800, shieldReload: 4000, zoneColor: 0x1e90ff },
  Athena:    { health: 130, damage: 12, shield: 55, bullets: 15, bulletReload: 700, shieldReload: 3500, zoneColor: 0xc0c0c0 },
  Ares:      { health: 180, damage: 30, shield: 20, bullets: 8,  bulletReload: 1100, shieldReload: 5500, zoneColor: 0xff4500 },
  Aphrodite: { health: 120, damage: 10, shield: 60, bullets: 16, bulletReload: 600, shieldReload: 3000, zoneColor: 0xff69b4 },
  Apollo:    { health: 130, damage: 18, shield: 35, bullets: 12, bulletReload: 900, shieldReload: 4500, zoneColor: 0xffff66 },
  Artemis:   { health: 125, damage: 16, shield: 30, bullets: 12, bulletReload: 850, shieldReload: 4250, zoneColor: 0x66ff66 },
  Hephaestus:{ health: 200, damage: 22, shield: 25, bullets: 10, bulletReload: 1200, shieldReload: 6000, zoneColor: 0xcd853f },
  Hermes:    { health: 130, damage: 14, shield: 40, bullets: 14, bulletReload: 750, shieldReload: 3750, zoneColor: 0x3cb371 },
  Dionysus:  { health: 140, damage: 13, shield: 45, bullets: 12, bulletReload: 900, shieldReload: 4500, zoneColor: 0xba55d3 },
  Demeter:   { health: 150, damage: 12, shield: 50, bullets: 15, bulletReload: 800, shieldReload: 4000, zoneColor: 0x20b2aa },
  Hera:      { health: 160, damage: 15, shield: 70, bullets: 16, bulletReload: 700, shieldReload: 3500, zoneColor: 0xff69b4 },
  Hades:     { health: 160, damage: 24, shield: 35, bullets: 10, bulletReload: 1000, shieldReload: 5000, zoneColor: 0x8b008b }
};

const BUTTONS = {
  A: 0, // Sprint boost.
  B: 1, // Melee Attack (regular).
  X: 2, // Melee Attack (spin).
  Y: 3  // Projectile (long-range) attack.
};

const PLAYER_SPEED = 100;
const ENEMY_SPEED = 50;

/* ======================================================================
   Object Pool (Simple Stub)
   ====================================================================== */
class Pool {
  constructor(createFn) {
    this.createFn = createFn;
    this.pool = [];
  }
  get(...args) {
    return (this.pool.length > 0) ? this.pool.pop() : this.createFn(...args);
  }
  release(obj) {
    this.pool.push(obj);
  }
}

/* ======================================================================
   MINIMAP & HUD
   ====================================================================== */
// The minimap is a secondary camera (see MainScene).
// The HUD is a text object showing detailed combatant stats.
// A div with id "hudTooltip" is available for contextual tooltips.

/* ======================================================================
   EASYSTAR SETUP (A* Pathfinding Stub)
   ====================================================================== */
// For demonstration, we initialize EasyStar with a simple walkable grid.
// In a full game, you would construct a grid based on your level design.
const easyStar = new EasyStar.js();
const gridCols = 48, gridRows = 36;  // 32x32 tiles for a 1536x1152 world.
const grid = [];
for (let y = 0; y < gridRows; y++) {
  const col = [];
  for (let x = 0; x < gridCols; x++) {
    col.push(0); // All tiles walkable.
  }
  grid.push(col);
}
easyStar.setGrid(grid);
easyStar.setAcceptableTiles([0]);
// TODO: Add obstacles and use easyStar.findPath() in enemy movement when needed.

/* ======================================================================
   Preload & Animations for Greek Characters
   ====================================================================== */
class MainScene extends Phaser.Scene {
  constructor() {
    super('MainScene');
  }
  
  preload() {
    // For each god, load its spritesheet.
    Object.keys(GOD_SPRITES).forEach(god => {
      // Assuming assets are in "assets/" and named like "zeus_spritesheet.png"
      this.load.spritesheet(GOD_SPRITES[god],
        'assets/' + GOD_SPRITES[god] + '_spritesheet.png',
        { frameWidth: 64, frameHeight: 64 }
      );
    });
    // Also load an asset for the projectile attack.
    this.load.spritesheet("projectile", "assets/projectile_spritesheet.png", { frameWidth: 16, frameHeight: 16 });
    
    // (Optional: load a tilemap or ground image from the provided Greek-themed asset packs.)
  }
  
  create() {
    // Create animations for each god (example for Zeus; similar for others).
    // In a full game, create animations for walking, idle, and attack.
    this.anims.create({
      key: 'zeus-walk',
      frames: this.anims.generateFrameNumbers('zeus', { start: 0, end: 3 }),
      frameRate: 8,
      repeat: -1
    });
    this.anims.create({
      key: 'zeus-attack',
      frames: this.anims.generateFrameNumbers('zeus', { start: 4, end: 7 }),
      frameRate: 10,
      repeat: 0
    });
    // TODO: Similarly, create animations for other gods (Poseidon, Athena, etc.)
    
    // Set up background, e.g. a tilemap from the Greek-themed assets.
    // this.add.image(GAME_WIDTH/2, GAME_HEIGHT/2, "temple-tileset");
    
    this.cameras.main.setBackgroundColor(0x222222);
    
    // Add ASCII "GodLight" banner and credit.
    const asciiArt =
`   ____       _     _     _     _ _ 
  / ___| ___ | |__ (_)___| |__ (_) |
 | |  _ / _ \\| '_ \\| / __| '_ \\| | |
 | |_| | (_) | |_) | \\__ \\ | | | | |
  \\____|\\___/|_.__/|_|___/_| |_|_|_|`;
    this.add.text(GAME_WIDTH/2 - 300, 10, asciiArt, { fontFamily: 'monospace', fontSize: '20px', fill: '#fff' });
    this.add.text(GAME_WIDTH/2 - 100, 60, "by Aesop Yashchin", { fontSize: '16px', fill: '#fff' });
    
    // Create central Hades realm (circle with radius 75).
    this.hadesCircle = this.add.circle(GAME_WIDTH/2, GAME_HEIGHT/2, 75, GOD_CONFIG["Hades"].zoneColor, 0.5);
    
    // Create pie zones for gods except Hades.
    this.pieZones = [];
    let centerX = GAME_WIDTH / 2;
    let centerY = GAME_HEIGHT / 2;
    let arenaRadius = Math.min(GAME_WIDTH, GAME_HEIGHT) / 2 - 20;
    let godsForZones = GODS.filter(g => g.name !== "Hades");
    const numZones = godsForZones.length;
    for (let i = 0; i < numZones; i++) {
      let startAngle = i * (2 * Math.PI / numZones);
      let endAngle = (i + 1) * (2 * Math.PI / numZones);
      let god = godsForZones[i].name;
      let zoneColor = (GOD_CONFIG[god] && GOD_CONFIG[god].zoneColor) || 0xffffff;
      let zone = new PieZone(this, centerX, centerY, arenaRadius, startAngle, endAngle, god, zoneColor);
      this.pieZones.push(zone);
    }
    
    // Spawn exactly 13 combatants (one for each god).
    this.players = [];
    this.enemies = [];
    // For simplicity, let the first 4 gods (from GODS) be human-controlled (players)
    // and the remaining 9 be AI-controlled (enemies).
    for (let i = 0; i < GODS.length; i++) {
      let godName = GODS[i].name;
      let spawnX, spawnY;
      if (godName === "Hades") {
        let angle = Phaser.Math.FloatBetween(0, 2 * Math.PI);
        let r = Phaser.Math.FloatBetween(0, 75);
        spawnX = centerX + r * Math.cos(angle);
        spawnY = centerY + r * Math.sin(angle);
      } else {
        let zone = this.pieZones.find(z => z.god === godName);
        if (zone) {
          let angle = Phaser.Math.FloatBetween(zone.startAngle, zone.endAngle);
          let r = Phaser.Math.FloatBetween(0, zone.radius * 0.8);
          spawnX = zone.centerX + r * Math.cos(angle);
          spawnY = zone.centerY + r * Math.sin(angle);
        } else {
          spawnX = Phaser.Math.Between(50, GAME_WIDTH - 50);
          spawnY = Phaser.Math.Between(50, GAME_HEIGHT - 50);
        }
      }
      if (i < 4) {
        // Create Player using the god's sprite key.
        let player = new Player(this, spawnX, spawnY, i);
        player.god = godName;
        // Change the sprite to use the god-specific spritesheet.
        player.sprite.setTexture(GOD_SPRITES[godName]);
        // Set animations as needed.
        player.sprite.anims.play(GOD_SPRITES[godName] + "-walk", true);
        let cfg = GOD_CONFIG[godName];
        player.maxHealth = cfg.health;
        player.health = cfg.health;
        player.damage = cfg.damage;
        player.maxShield = cfg.shield;
        player.shield = cfg.shield;
        player.maxBullets = cfg.bullets;
        player.currentBullets = cfg.bullets;
        // Assign a home area.
        player.homeZone = (godName === "Hades") ? this.hadesCircle : this.pieZones.find(z => z.god === godName);
        this.players.push(player);
      } else {
        // Create Enemy.
        let enemy = new Enemy(this, spawnX, spawnY, i);
        enemy.god = godName;
        enemy.sprite.setTexture(GOD_SPRITES[godName]);
        enemy.sprite.anims.play(GOD_SPRITES[godName] + "-walk", true);
        let cfg = GOD_CONFIG[godName];
        enemy.maxHealth = cfg.health;
        enemy.health = cfg.health;
        enemy.damage = cfg.damage;
        enemy.maxShield = cfg.shield;
        enemy.shield = cfg.shield;
        enemy.maxBullets = cfg.bullets;
        enemy.currentBullets = cfg.bullets;
        enemy.homeZone = this.pieZones.find(z => z.god === godName);
        this.enemies.push(enemy);
      }
    }
    
    // Spawn a power-up every 15 seconds.
    this.time.addEvent({
      delay: 15000,
      callback: () => {
        let puX = Phaser.Math.Between(50, GAME_WIDTH - 50);
        let puY = Phaser.Math.Between(50, GAME_HEIGHT - 50);
        let powerUp = new PowerUp(this, puX, puY, "shield");
        this.powerUps.push(powerUp);
      },
      loop: true
    });
    
    // Add help icon (toggle on/off with "?" key or click).
    this.helpIcon = this.add.text(GAME_WIDTH - 30, 10, "?", { fontSize: '24px', fill: '#fff' });
    this.helpIcon.setInteractive();
    this.helpIcon.on('pointerdown', () => {
      if (this.scene.isActive('HelpScene')) {
        this.scene.stop('HelpScene');
      } else {
        this.scene.launch('HelpScene', { previousScene: 'MainScene' });
      }
    });
    this.input.keyboard.on('keydown', (event) => {
      if (event.key === '?') {
        if (this.scene.isActive('HelpScene')) {
          this.scene.stop('HelpScene');
        } else {
          this.scene.launch('HelpScene', { previousScene: 'MainScene' });
        }
      }
    });
    
    // Gamepad assignment.
    if (this.input.gamepad.total > 0) {
      this.input.gamepad.gamepads.forEach((pad, idx) => {
        if (this.players[idx] && !this.players[idx].gamepad) {
          this.players[idx].gamepad = pad;
        }
      });
    }
    this.input.gamepad.on('connected', (pad) => {
      this.players.forEach((player, idx) => {
        if (!player.gamepad && this.input.gamepad.gamepads[idx]) {
          player.gamepad = this.input.gamepad.gamepads[idx];
        }
      });
    });
    
    // Create a minimap camera in the upper-left corner.
    this.minimap = this.cameras.add(10, 10, 200, 150).setZoom(200 / GAME_WIDTH).setBackgroundColor(0x222222);
    
    // Create a HUD text object.
    this.hudText = this.add.text(10, GAME_HEIGHT - 80, "", { fontSize: '20px', fill: '#fff' });
  }
  
  spawnMeleeAttack(x, y, attackType, shooter) {
    let offset = 0, width = 0, height = 0, damageMultiplier = 1;
    if (attackType === "regular") {
      offset = 20;
      width = 30; height = 20;
      damageMultiplier = 1;
    } else if (attackType === "spin") {
      offset = 0;
      width = 50; height = 50;
      damageMultiplier = 0.7;
    }
    let attackX = x, attackY = y;
    if (offset > 0) {
      attackX = x + shooter.lastFacing.x * offset;
      attackY = y + shooter.lastFacing.y * offset;
    }
    let rotation = (attackType === "spin") ? 0 : Math.atan2(shooter.lastFacing.y, shooter.lastFacing.x);
    this.spawnMeleeAttackHitbox(attackX, attackY, width, height, rotation, shooter.damage * damageMultiplier, shooter);
  }
  
  spawnMeleeAttackHitbox(x, y, width, height, rotation, damage, shooter) {
    let melee = new MeleeAttack(this, x, y, width, height, rotation, damage, shooter);
    this.meleeAttacks.push(melee);
    // TODO: Trigger particle effects on impact.
  }
  
  spawnProjectileAttack(x, y, shooter, dirX, dirY) {
    let speed = 500;
    let mag = Math.sqrt(dirX * dirX + dirY * dirY);
    if (mag === 0) { dirX = shooter.lastFacing.x; dirY = shooter.lastFacing.y; }
    else { dirX /= mag; dirY /= mag; }
    let velX = dirX * speed;
    let velY = dirY * speed;
    let damage = shooter.damage * 1.2;
    let projectile = new ProjectileAttack(this, x, y, "projectile", velX, velY, damage, shooter);
    this.projectiles.push(projectile);
  }
  
  updateProjectileAttacks(delta) {
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      let proj = this.projectiles[i];
      if (!proj.update(delta)) {
        this.projectiles.splice(i, 1);
      } else {
        let allTargets = this.players.concat(this.enemies);
        for (let target of allTargets) {
          if (target !== proj.owner &&
              Phaser.Geom.Intersects.RectangleToRectangle(proj.getBounds(), target.sprite.getBounds())) {
            let dmg = proj.damage;
            if (target.shield > 0) {
              let remainder = dmg - target.shield;
              target.shield = Math.max(0, target.shield - dmg);
              if (remainder > 0) {
                target.health = Math.max(0, target.health - remainder);
              }
            } else {
              target.health = Math.max(0, target.health - dmg);
            }
            proj.destroy();
            this.projectiles.splice(i, 1);
            break;
          }
        }
      }
    }
  }
  
  updatePowerUps(delta) {
    for (let i = this.powerUps.length - 1; i >= 0; i--) {
      let pu = this.powerUps[i];
      if (!pu.update(delta)) {
        this.powerUps.splice(i, 1);
      } else {
        this.players.forEach(player => {
          if (Phaser.Geom.Intersects.RectangleToRectangle(pu.getBounds(), player.sprite.getBounds())) {
            // For demonstration, add 20 shield.
            player.shield += 20;
            pu.destroy();
            this.powerUps.splice(i, 1);
          }
        });
      }
    }
  }
  
  update(time, delta) {
    this.pieZones.forEach(zone => zone.updateDisplay(this.players));
    this.hadesCircle.setPosition(GAME_WIDTH/2, GAME_HEIGHT/2);
    
    for (let i = this.meleeAttacks.length - 1; i >= 0; i--) {
      let attack = this.meleeAttacks[i];
      if (!attack.update(delta)) {
        this.meleeAttacks.splice(i, 1);
      } else {
        let allTargets = this.players.concat(this.enemies);
        for (let target of allTargets) {
          if (target !== attack.owner &&
              Phaser.Geom.Intersects.RectangleToRectangle(attack.getBounds(), target.sprite.getBounds())) {
            let dmg = attack.damage;
            if (target.shield > 0) {
              let remainder = dmg - target.shield;
              target.shield = Math.max(0, target.shield - dmg);
              if (remainder > 0) {
                target.health = Math.max(0, target.health - remainder);
              }
            } else {
              target.health = Math.max(0, target.health - dmg);
            }
            attack.destroy();
            this.meleeAttacks.splice(i, 1);
            break;
          }
        }
      }
    }
    
    this.updateProjectileAttacks(delta);
    this.updatePowerUps(delta);
    
    this.players.forEach((player, i) => {
      player.update();
      if (player.health <= 0) {
        player.destroy();
        this.players.splice(i, 1);
      }
    });
    
    this.enemies.forEach((enemy, i) => {
      enemy.update(time, delta);
      if (enemy.health <= 0) {
        enemy.sprite.destroy();
        enemy.nameText.destroy();
        enemy.healthBar.destroy();
        this.enemies.splice(i, 1);
      }
    });
    
    let allChars = this.players.concat(this.enemies);
    let hudInfo = "Combatants Left: " + allChars.length + "\n";
    allChars.forEach((char, idx) => {
      let label = (char.playerIndex !== undefined) ? ("P" + char.playerIndex + ": " + char.god)
                                                  : ("E" + idx + ": " + char.god);
      hudInfo += label + " - HP: " + char.health + ", Shield: " + char.shield + "\n";
    });
    this.hudText.setText(hudInfo);
    
    // Win condition: if only one unique god remains.
    let uniqueGods = new Set(allChars.map(ch => ch.god));
    if (allChars.length > 0 && uniqueGods.size === 1) {
      let winningGod = Array.from(uniqueGods)[0];
      this.scene.start('WinScene', { god: winningGod });
    }
  }
  
  createPlaceholderGraphics(key, width, height, color) {
    let graphics = this.make.graphics({ x: 0, y: 0, add: false });
    graphics.fillStyle(color, 1);
    graphics.fillRect(0, 0, width, height);
    graphics.generateTexture(key, width, height);
    graphics.destroy();
  }
  
  createTriangleTexture(key, width, height, color) {
    let graphics = this.make.graphics({ x: 0, y: 0, add: false });
    graphics.fillStyle(color, 1);
    graphics.beginPath();
    graphics.moveTo(width/2, 0);
    graphics.lineTo(0, height);
    graphics.lineTo(width, height);
    graphics.closePath();
    graphics.fillPath();
    graphics.generateTexture(key, width, height);
    graphics.destroy();
  }
}

/* ======================================================================
   Win Scene Definition
   ====================================================================== */
class WinScene extends Phaser.Scene {
  constructor() {
    super('WinScene');
  }
  init(data) {
    this.winningGod = data.god;
  }
  create() {
    this.cameras.main.setBackgroundColor(0x222222);
    this.add.text(GAME_WIDTH/2 - 200, GAME_HEIGHT/2 - 100, "The " + this.winningGod + " has won!", { fontSize: '48px', fill: '#fff' });
    let btn = document.createElement("button");
    btn.id = "restartBtn";
    btn.textContent = "Restart Game";
    btn.onclick = () => {
      btn.remove();
      this.scene.start('MainScene');
    };
    document.body.appendChild(btn);
  }
}

/* ======================================================================
   Help Scene Definition (Toggle with "?")
   ====================================================================== */
class HelpScene extends Phaser.Scene {
  constructor() {
    super('HelpScene');
  }
  init(data) {
    this.previousScene = data.previousScene || 'MainScene';
  }
  create() {
    this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.7);
    let helpText =
`Keyboard Controls:

Player 0:
  Move: Arrow Keys
  Sprint: SHIFT
  Regular Melee: SPACE
  Spin Melee: Q
  Projectile Attack: E

Player 1:
  Move: W A S D
  Sprint: CONTROL
  Regular Melee: F
  Spin Melee: G
  Projectile Attack: H

Player 2:
  Move: I J K L
  Sprint: U
  Regular Melee: O
  Spin Melee: P
  Projectile Attack: [

Player 3:
  Move: Numpad 8/4/6/2
  Sprint: Numpad 0
  Regular Melee: Numpad 1
  Spin Melee: Numpad 3
  Projectile Attack: Numpad 5

Additional:
  Press "?" to toggle this help screen.`;
    this.add.text(50, 50, helpText, { fontSize: '20px', fill: '#fff', wordWrap: { width: GAME_WIDTH - 100 } });
    this.input.keyboard.once('keydown-?', () => {
      this.scene.stop('HelpScene');
    });
    let closeBtn = document.createElement("button");
    closeBtn.id = "closeHelpBtn";
    closeBtn.textContent = "Close Help";
    closeBtn.onclick = () => {
      closeBtn.remove();
      this.scene.stop('HelpScene');
    };
    document.body.appendChild(closeBtn);
  }
}

/* ======================================================================
   Game Configuration and Initialization
   ====================================================================== */
const config = {
  type: Phaser.AUTO,
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  scene: [MainScene, WinScene, HelpScene],
  parent: 'phaser-example',
  input: { gamepad: true }
};

const game = new Phaser.Game(config);

/*
  Additional Suggestions for a Playable Game:
  
  Enhanced AI:
    - Use EasyStar.js with a proper grid of obstacles so enemies can find paths.
    - Expand the enemy state machine to include robust patrol, chase, retreat, and dodge states.
  
  Visual & Audio:
    - Replace placeholders with high-quality sprites and animations (using the provided Greek-themed asset packs).
    - Add particle effects for melee impacts and explosions via Phaser’s particle emitters.
    - Incorporate an adaptive soundtrack and sound effects.
  
  Power-Ups & Special Moves:
    - Expand the PowerUp class to include various types (shield, speed, etc.) and add unique special moves for each god.
  
  UI/HUD Enhancements:
    - Build a comprehensive HUD with detailed player stats and contextual tooltips (using the hudTooltip div).
    - Include in-game tutorials to guide new players.
  
  Code Organization & Performance:
    - Refactor the code into separate modules/files.
    - Implement robust object pooling for transient objects (melee hitboxes, projectiles, and enemies) to reduce garbage collection overhead.
  
  With further testing and balancing, these improvements would help convert this prototype into a truly playable game.
*/
</script>
</body>
</html>
