<!DOCTYPE html>
<html>
<head>
    <title>GodLight - Combat of the Gods</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        .cooldown-indicator {
            position: absolute;
            bottom: 50px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-family: monospace;
            width: 150px;
        }
        .cooldown-bar {
            width: 100%;
            height: 5px;
            background: #333;
            border-radius: 3px;
            margin-top: 2px;
        }
        .cooldown-progress {
            height: 100%;
            background: #0f0;
            border-radius: 3px;
            transition: width 0.1s linear;
        }
        #primary-cooldown {
            right: 10px;
        }
        #special-cooldown {
            right: 170px;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #character-select {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .character-button {
            margin: 5px;
            padding: 10px;
            background: #333;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }
        .character-button:hover {
            background: #444;
        }
        .hidden {
            display: none;
        }
        #player-stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">WASD: Move<br>Space: Attack<br>E: Special Ability<br>Shift: Dash</div>
    <div id="player-stats">Health: 100<br>Shield: 100</div>
    <div id="primary-cooldown" class="cooldown-indicator">
        Primary Attack (Space)
        <div class="cooldown-bar">
            <div class="cooldown-progress" style="width: 100%"></div>
        </div>
    </div>
    <div id="special-cooldown" class="cooldown-indicator">
        Special Ability (E)
        <div class="cooldown-bar">
            <div class="cooldown-progress" style="width: 100%"></div>
        </div>
    </div>
    <div id="character-select">
        <h2>Select Your God</h2>
        <div id="character-buttons"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script>
        // Game state
        let gameState = 'character-select'; // character-select, playing
        let selectedGod = null;

        // Character definitions
        const gods = {
            Zeus: {
                color: 0xFFD700,
                primaryAttack: (scene, position, direction) => {
                    // Calculate position 10 units ahead of player in movement direction
                    const forward = direction.clone().normalize();
                    const strikePos = position.clone().add(forward.multiplyScalar(10));
                    createLightningStrike(scene, strikePos, forward);
                },
                specialAbility: (scene, position) => {
                    // Create lightning strikes in a circle
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const direction = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                        const strikePos = position.clone().add(direction.multiplyScalar(10));
                        createLightningStrike(scene, strikePos, direction);
                    }
                },
                cooldowns: {
                    primaryAttack: 500,    // 0.5 seconds
                    specialAbility: 5000   // 5 seconds
                }
            },
            Poseidon: {
                color: 0x0000FF,
                primaryAttack: (scene, position, direction) => {
                    // Water blast implementation
                },
                specialAbility: (scene, position) => {
                    createWhirlpool(scene, position);
                },
                cooldowns: {
                    primaryAttack: 400,
                    specialAbility: 8000
                }
            }
            // Add other gods here...
        };

        // Initialize character selection
        const charButtons = document.getElementById('character-buttons');
        Object.keys(gods).forEach(god => {
            const button = document.createElement('button');
            button.className = 'character-button';
            button.textContent = god;
            button.onclick = () => selectCharacter(god);
            charButtons.appendChild(button);
        });

        function selectCharacter(god) {
            selectedGod = god;
            document.getElementById('character-select').classList.add('hidden');
            gameState = 'playing';
            initGame();
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000033);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Arena setup
        const ARENA_SIZE = 100;
        const ZONE_COUNT = 13; // One for each god
        const ZONE_ANGLE = (Math.PI * 2) / ZONE_COUNT;

        function createArena() {
            const arenaGeometry = new THREE.CircleGeometry(ARENA_SIZE, 64);
            const arenaMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333366,
                shininess: 10
            });
            const arena = new THREE.Mesh(arenaGeometry, arenaMaterial);
            arena.rotation.x = -Math.PI / 2;
            scene.add(arena);

            // Create zone indicators
            for (let i = 0; i < ZONE_COUNT; i++) {
                const zoneGeometry = new THREE.CircleGeometry(ARENA_SIZE, 32, i * ZONE_ANGLE, ZONE_ANGLE);
                const zoneMaterial = new THREE.MeshPhongMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.3
                });
                const zone = new THREE.Mesh(zoneGeometry, zoneMaterial);
                zone.rotation.x = -Math.PI / 2;
                scene.add(zone);
            }
        }

        // Player setup
        function createPlayer(god) {
            const playerGroup = new THREE.Group();
            
            const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
            const playerMaterial = new THREE.MeshPhongMaterial({ 
                color: gods[god].color,
                emissive: gods[god].color,
                emissiveIntensity: 0.2
            });
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerGroup.add(playerMesh);

            // Divine aura
            const auraGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const auraMaterial = new THREE.MeshPhongMaterial({
                color: gods[god].color,
                transparent: true,
                opacity: 0.2
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            playerGroup.add(aura);

            playerGroup.position.y = 1;
            scene.add(playerGroup);

            return playerGroup;
        }

        // Game initialization
        function initGame() {
            createArena();
            const player = createPlayer(selectedGod);
            
            // Set up initial camera position
            camera.position.set(0, 40, 50);
            camera.lookAt(player.position);

            // Set up controls
            const keys = {};
            window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

            // Player properties
            player.userData = {
                moveSpeed: 0.3,
                health: 100,
                shield: 100,
                lastPrimaryAttack: 0,
                lastSpecialAbility: 0,
                lastMovementDir: new THREE.Vector3(0, 0, -1)
            };
            
            // Initialize game loop
            function animate() {
                requestAnimationFrame(animate);
                
                if (gameState === 'playing') {
                    // Handle movement
                    let movementX = 0;
                    let movementZ = 0;
                    if (keys['w']) movementZ -= 1;
                    if (keys['s']) movementZ += 1;
                    if (keys['a']) movementX -= 1;
                    if (keys['d']) movementX += 1;

                    // Update position if moving
                    if (movementX !== 0 || movementZ !== 0) {
                        const normalizedMovement = new THREE.Vector3(movementX, 0, movementZ).normalize();
                        player.position.x += normalizedMovement.x * player.userData.moveSpeed;
                        player.position.z += normalizedMovement.z * player.userData.moveSpeed;
                        player.userData.lastMovementDir = normalizedMovement;

                        // Keep player in bounds
                        const distanceFromCenter = Math.sqrt(
                            player.position.x * player.position.x + 
                            player.position.z * player.position.z
                        );
                        
                        if (distanceFromCenter > ARENA_SIZE) {
                            const angle = Math.atan2(player.position.z, player.position.x);
                            player.position.x = Math.cos(angle) * ARENA_SIZE;
                            player.position.z = Math.sin(angle) * ARENA_SIZE;
                        }

                        // Update player rotation to face movement direction
                        player.rotation.y = Math.atan2(movementX, -movementZ);
                    }

                    // Update camera to follow player
                    const targetCameraX = player.position.x;
                    const targetCameraZ = player.position.z + 50;
                    camera.position.x += (targetCameraX - camera.position.x) * 0.1;
                    camera.position.z += (targetCameraZ - camera.position.z) * 0.1;
                    camera.lookAt(player.position);

                    // Handle combat abilities
                    const currentTime = Date.now();
                    const godAbilities = gods[selectedGod];

                    // Update cooldown indicators
                    const primaryProgress = Math.min(100, 
                        ((currentTime - player.userData.lastPrimaryAttack) / godAbilities.cooldowns.primaryAttack) * 100);
                    const specialProgress = Math.min(100,
                        ((currentTime - player.userData.lastSpecialAbility) / godAbilities.cooldowns.specialAbility) * 100);
                    
                    document.querySelector('#primary-cooldown .cooldown-progress').style.width = `${primaryProgress}%`;
                    document.querySelector('#special-cooldown .cooldown-progress').style.width = `${specialProgress}%`;

                    // Primary attack (Space)
                    if (keys[' '] && 
                        currentTime - player.userData.lastPrimaryAttack > godAbilities.cooldowns.primaryAttack) {
                        godAbilities.primaryAttack(scene, player.position, player.userData.lastMovementDir.clone());
                        player.userData.lastPrimaryAttack = currentTime;
                    }

                    // Special ability (E)
                    if (keys['e'] && 
                        currentTime - player.userData.lastSpecialAbility > godAbilities.cooldowns.specialAbility) {
                        godAbilities.specialAbility(scene, player.position);
                        player.userData.lastSpecialAbility = currentTime;
                    }

                    // Check for damage from abilities
                    scene.children.forEach(object => {
                        if (object.userData && object.userData.damage) {
                            // Only check recent attacks
                            if (currentTime - object.userData.createdTime < 100) {
                                const distance = object.position.distanceTo(player.position);
                                if (distance < 2) { // Damage radius
                                    player.userData.health -= object.userData.damage;
                                    // Update stats display
                                    document.getElementById('player-stats').innerHTML = 
                                        `Health: ${player.userData.health}<br>Shield: ${player.userData.shield}`;
                                }
                            }
                        }
                    });

                    // Update divine aura
                    const time = Date.now() * 0.001;
                    player.children[1].scale.setScalar(1 + Math.sin(time * 2) * 0.1);
                    player.children[1].material.opacity = 0.2 + Math.sin(time * 2) * 0.1;
                    
                    // Update player stats display
                    document.getElementById('player-stats').innerHTML = 
                        `Health: ${player.userData.health}<br>Shield: ${player.userData.shield}`;
                }

                renderer.render(scene, camera);
            }

            animate();
        }

        // Special effects
        function createLightningStrike(scene, position, direction) {
            // Create zigzag lightning path
            const points = [];
            const segments = 4;
            const length = 10;
            const zigzagWidth = 1;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const x = (i % 2) * zigzagWidth * (i === segments ? 0 : (i % 3 === 0 ? -1 : 1));
                points.push(new THREE.Vector3(x, 0, t * length));
            }
            
            const lightningGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const lightningMaterial = new THREE.LineBasicMaterial({
                color: 0xFFFF00,
                linewidth: 3
            });
            const lightning = new THREE.Line(lightningGeometry, lightningMaterial);
            
            // Position and rotate
            lightning.position.copy(position);
            lightning.position.y = 1;
            
            if (direction) {
                const angle = Math.atan2(direction.x, direction.z);
                lightning.rotation.y = angle;
            }
            
            // Add glow effect
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xFFFF00) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                        gl_FragColor = vec4(color, intensity);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            // Add flash effect
            const flash = new THREE.PointLight(0xFFFF00, 2, 10);
            flash.position.copy(position);
            scene.add(flash);
            
            // Add to scene
            scene.add(lightning);
            
            // Add damage properties
            lightning.userData = {
                damage: 15,
                damageType: 'lightning',
                createdTime: Date.now()
            };

            // Animate lightning
            let frame = 0;
            const maxFrames = 5;
            const animate = () => {
                if (frame >= maxFrames) {
                    scene.remove(lightning);
                    scene.remove(flash);
                    return;
                }
                
                // Randomly adjust zigzag points for crackling effect
                const positions = lightning.geometry.attributes.position.array;
                for (let i = 3; i < positions.length - 3; i += 3) {
                    positions[i] += (Math.random() - 0.5) * 0.2;
                }
                lightning.geometry.attributes.position.needsUpdate = true;
                
                frame++;
                requestAnimationFrame(animate);
            };
            
            animate();
            
            // Remove after effect
            setTimeout(() => {
                scene.remove(lightning);
                scene.remove(flash);
            }, 100);
        }
            
            // Add damage collider
            lightning.userData = {
                damage: 15,
                damageType: 'lightning',
                createdTime: Date.now()
            };
            
            scene.add(lightning);

            // Visual effects
            const flash = new THREE.PointLight(0xFFFF00, 1, 10);
            flash.position.copy(position);
            scene.add(flash);

            // Remove after effect
            setTimeout(() => {
                scene.remove(lightning);
                scene.remove(flash);
            }, 100);
        }

        function createWhirlpool(scene, position) {
            // Whirlpool implementation here
        }

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>